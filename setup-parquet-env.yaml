AWSTemplateFormatVersion: '2010-09-09'
Resources:
  GlueDatabase:
    Type: AWS::Glue::Database
    Properties:
      CatalogId: !Ref AWS::AccountId
      DatabaseInput: 
        Name: "firehosedb"

  GlueTable:
    Type: AWS::Glue::Table
    Properties:
      CatalogId: !Ref AWS::AccountId
      DatabaseName: !Ref GlueDatabase
      TableInput:
        Name: "access_logs_parquet"
        Retention: 0
        StorageDescriptor:
          Columns:
            - Type: string
              Name: activity
            - Type: string
              Name: activity_id
            - Type: string
              Name: auth_protocol
            - Type: bigint
              Name: auth_protocol_id
            - Type: string
              Name: category_name
            - Type: bigint
              Name: category_uid
            - Type: string
              Name: class_name
            - Type: bigint
              Name: class_uid
            - Type: boolean
              Name: is_cleartext
            - Type: struct<hostname:string,ip:string,instance_uid:string,interface_id:string,svc_name":string>
              Name: dst_endpoint
            - Type: string
              Name: dst_user
            - Type: array<struct<id:string,type:string,alternateId:string,displayName:string,detailEntry:string>>
              Name: enrichments
            - Type: string
              Name: _time
            - Type: string
              Name: logon_type
            - Type: bigint
              Name: logon_type_id
            - Type: string
              Name: displaymessage
            - Type: string
              Name: ref_time
            - Type: string
              Name: profile
            - Type: string
              Name: session_uid
            - Type: string
              Name: severity
            - Type: bigint
              Name: severity_id
            - Type: struct<hostname:string,ip:string,interface_id:string>
              Name: src_endpo int
            - Type: struct<type:string,displayname:string,,alternateID:string>
              Name: src_user
            - Type: string
              Name: status
            - Type: string
              Name: status_code
            - Type: string
              Name: status_detail
            - Type: bigint
              Name: status_id
            - Type: bigint
              Name: type_uid
            - Type: string
              Name: type_name
            - Type: string
              Name: partition_0
          Location: !Sub 's3://${MyS3Bucket}/access-logs-parquet'
          InputFormat: org.apache.hadoop.hive.ql.io.parquet.MapredParquetInputFormat
          OutputFormat: org.apache.hadoop.hive.ql.io.parquet.MapredParquetOutputFormat
          Compressed: false
          NumberOfBuckets: -1
          SerdeInfo:
            SerializationLibrary: org.apache.hadoop.hive.ql.io.parquet.serde.ParquetHiveSerDe
            Parameters:
              serialization.format: '1'
          BucketColumns: []
          SortColumns: []
          StoredAsSubDirectories: false
        PartitionKeys: []

  MyS3Bucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Sub 'access-logs-parquet-${AWS::AccountId}'
      AccessControl: Private

  FirehoseDeliveryRole:
    Type: "AWS::IAM::Role"
    Properties:
      AssumeRolePolicyDocument:
       Version: "2012-10-17"
       Statement:
         -
          Effect: "Allow"
          Principal:
            Service:
             - "firehose.amazonaws.com"
          Action:
             - "sts:AssumeRole"
          Condition:
             StringEquals:
               "sts:ExternalId": !Ref "AWS::AccountId"
      Path: "/"
      Policies:
        - PolicyName: firehose_delivery_policy
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - 's3:AbortMultipartUpload'
                  - 's3:GetBucketLocation'
                  - 's3:GetObject'
                  - 's3:ListBucket'
                  - 's3:ListBucketMultipartUploads'
                  - 's3:PutObject'
                Resource:
                  - !Sub 'arn:aws:s3:::${MyS3Bucket}'
                  - !Sub 'arn:aws:s3:::${MyS3Bucket}*'
              - Effect: Allow
                Action: 'glue:GetTableVersions'
                Resource: '*'

  MyKDFH:
    Type: AWS::KinesisFirehose::DeliveryStream
    DependsOn: GlueTable
    Properties:
     ExtendedS3DestinationConfiguration:
       BucketARN: !Sub 'arn:aws:s3:::${MyS3Bucket}'
       BufferingHints:
         IntervalInSeconds: 60
         SizeInMBs: 64
       CompressionFormat: UNCOMPRESSED
       Prefix: access-logs-parquet/
       RoleARN: !GetAtt FirehoseDeliveryRole.Arn
       ProcessingConfiguration:
         Enabled: true
         Processors:
          - Type: Lambda
            Parameters:
             - ParameterName: LambdaArn
               ParameterValue: !GetAtt tsvtoparquetLambda.Arn
       DataFormatConversionConfiguration:
         Enabled: True
         SchemaConfiguration:
           CatalogId: !Ref AWS::AccountId
           RoleARN: !GetAtt FirehoseDeliveryRole.Arn
           DatabaseName: !Ref GlueDatabase
           TableName: !Ref GlueTable
           Region: !Ref AWS::Region
           VersionId: LATEST
         InputFormatConfiguration:
           Deserializer:
             OpenXJsonSerDe: {}
         OutputFormatConfiguration:
           Serializer:
             ParquetSerDe: {}
     DeliveryStreamName: 'access-logs-sink-parquet'
     DeliveryStreamType: 'DirectPut'
  
  InvokeLambdaPolicy:
   Type: AWS::IAM::Policy
   Properties:
     PolicyName: kfh_lambda_policy
     PolicyDocument:
      Version: 2012-10-17
      Statement:
        - Effect: Allow
          Action:
           - 'lambda:InvokeFunction'
          Resource:
           - !GetAtt tsvtoparquetLambda.Arn
     Roles:
        - !Ref FirehoseDeliveryRole

  tsvtoparquetLambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
       Version: '2012-10-17'
       Statement:
       - Effect: Allow
         Principal:
           Service:
           - lambda.amazonaws.com
         Action:
          - sts:AssumeRole
      Policies:
       - PolicyName: allowLambdaLogs
         PolicyDocument:
           Version: '2012-10-17'
           Statement:
           - Effect: Allow
             Action:
             - logs:*
             Resource: arn:aws:logs:*:*:*

  tsvtoparquetLambda:
    Type: AWS::Lambda::Function
    Properties:
      Description: aws:states:opt-in
      Code:
        ZipFile: |

          import base64
          import json

          def lambda_handler(event, context):
              """Sample pure Lambda function

              Parameters
              ----------
              event: dict, required
                  API Gateway Lambda Proxy Input Format

                  Event doc: https://docs.aws.amazon.com/apigateway/latest/developerguide/set-up-lambda-proxy-integrations.html#api-gateway-simple-proxy-for-lambda-input-format

              context: object, required
                  Lambda Context runtime methods and attributes

                  Context doc: https://docs.aws.amazon.com/lambda/latest/dg/python-context-object.html

              Returns
              ------
              API Gateway Lambda Proxy Output Format: dict

                  Return doc: https://docs.aws.amazon.com/apigateway/latest/developerguide/set-up-lambda-proxy-integrations.html
              """

              # try:
              #     ip = requests.get("http://checkip.amazonaws.com/")
              # except requests.RequestException as e:
              #     # Send some context about this error to Lambda Logs
              #     print(e)

              #     raise e
              output=[]
              for record in event['records']:
                  recordId = record['recordId']
                  data = base64.b64decode(record['data'])
                  data = json.loads(data.decode('utf8'))
                  #Base 64 encoded strings
                  #data = [['tom', 10], ['nick', 15], ['juli', 14]]
                  result=tranform_data(data)
                  #result = output1.to_json(orient="split")
                  #print('typeeeeeeee')
                  print(type(output))

                  output_record = {
                      'recordId': record['recordId'], # is this the problem? I used sequenceNumber, it is not right.
                      'result': 'Ok',
                      'data': base64.b64encode(json.dumps(result, separators=(',', ':')).encode('utf-8') + b'\n').decode(
                          'utf-8')

                  }
                  output.append(output_record)

              print(output)
              return {'records': output}
              #return {'records': output}

              '''
              bytes_encoded = bytes_encoded.encode(encoding='utf-8')
              print(bytes_encoded)
              #data=recordId.decode()
              str_decoded = bytes_encoded.decode()
              print(str_decoded)

              str_decoded = bytes_encoded.decode()
              print(type(str_decoded))

              return {
              "statusCode": 200,
              "body": json.dumps({
                  "message": "hello world"
                  # "location": ip.text.replace("\n", "")
              })
              }'''


          def get_activity_details(activityInfo):
              activity = "Unknown"
              activity_id = 0
              if "user.authentication" in activityInfo:
                  print('inside activity')
                  activity='Logon'
                  activity_id=1
              return activity,activity_id


          def get_auth_protocol(authProviderDetail):
              auth_protocol = "Unknown"
              auth_protocol_id = 0
              if "FACTOR" in authProviderDetail:
                  print('inside auth protocol')
                  auth_protocol = "Other  / MFA"
                  auth_protocol_id = 1
              return auth_protocol,auth_protocol_id


          def get_category():
              category_name='Audit Activity events'
              category_uid=3
              return category_name,category_uid


          def get_class():
              class_name="Authentication Audit"
              class_uid= 3002
              return class_name,class_uid


          def get_clearText_value(auth_protocol):
              is_clearText=False
              if ((auth_protocol!='FTP') and (auth_protocol!='TELNET')):
                  is_clearText==True

              return is_clearText


          def get_destination_endPoint(destination_endpoint):

              detination_details={"hostname":destination_endpoint['requestUri'],
              "ip":"",
              "instance_uid":"",
              "interface_id":"",
              "svc_name":destination_endpoint['url']}
              return detination_details


          def get_logon_type(login_transaction):
              logon_type=login_transaction['type']
              logon_type_id=0
              if "WEB" in logon_type:
                  logon_type_id=-1
              return  logon_type,logon_type_id


          def get_severity(severity):
              severity_id = -1
              if "INFO" in severity:
                  severity_id=1
              return  severity,severity_id


          def get_src_endpoint(data):
              src_end_point={
              "hostname": data['debugContext']['debugData']['requestUri'],
              "ip ": data['client']['ipAddress'],
              "interface_id": data['client']['device']
              }
              return src_end_point


          def get_src_user(data):
              src_user={
                  'type':data['actor']['type'],
                  'displayname':data['actor']['displayName'],
                  'alternateID':data['actor']['alternateId']
              }
              return src_user


          def get_status_details(data):
              status=data['outcome']['result']
              status_code	='N/A'
              status_detail=''
              status_id=-1
              if "SUCCESS" in status:
                  status_detail="LOGON_USER_INITIATED"
                  status_id=1

              return status,status_code,status_detail,status_id


          def tranform_data(data):
              #get activity


              activity,activity_id=get_activity_details(data['detail']['eventType'])
              auth_protocol,auth_protocol_id=get_auth_protocol(data['detail']['authenticationContext']['authenticationProvider'])
              category_name,category_uid=get_category()
              class_name,class_uid=get_class()
              is_cleartext=get_clearText_value(auth_protocol)
              dst_endpoint=get_destination_endPoint(data['detail']['debugContext']['debugData'])
              dst_user=data['detail']['actor']['alternateId']
              enrichments=data['detail']['target']
              _time=data['time']
              logon_type,logon_type_id=get_logon_type(data['detail']['transaction'])
              displayMessage=data['detail']['displayMessage']
              ref_time=data['time']
              profile=data['detail']['actor']['alternateId']
              session_uid=data['detail']['authenticationContext']['externalSessionId']
              severity,severity_id=get_severity(data['detail']['severity'])
              src_endpoint=get_src_endpoint(data['detail'])
              src_user=get_src_user(data['detail'])
              status,status_code,status_detail,status_id = get_status_details(data['detail'])
              type_uid='300201' #HardCoded
              type_name='Authentication Audit: Logon'

              json_data={

                  'activity':activity,
                  'activity_id':activity_id,
                  'auth_protocol':auth_protocol,
                  'auth_protocol_id':auth_protocol_id,
                  'category_name':category_name,
                  'category_uid':category_uid,
                  'class_name':class_name,
                  'class_uid':class_uid,
                  'is_cleartext':is_cleartext,
                  'dst_endpoint':dst_endpoint,
                  'dst_user':dst_user,
                  'enrichments':enrichments,
                  '_time':_time,
                  'logon_type':logon_type,
                  'logon_type_id':logon_type_id,
                  'displayMessage':displayMessage,
                  'ref_time':ref_time,
                  'profile':profile,
                  'session_uid':session_uid,
                  'severity':severity,
                  'severity_id':severity_id,
                  'src_endpoint':src_endpoint,
                  'src_user':src_user,
                  'status':status,
                  'status_code':status_code,
                  'status_detail':status_detail,
                  'status_id':status_id,
                  'type_uid':type_uid,
                  'type_name':type_name

              }
              '''data=[[activity,activity_id,auth_protocol,auth_protocol_id,category_name,category_uid,class_name,class_uid,is_cleartext,destination_endpoint,dst_user,enrichments,_time,logon_type,
                     logon_type_id,displayMessage,ref_time,profile,session_uid,severity,severity_id,src_endpoint,src_user,status,status_code,
                     status_detail,status_id,type_uid,type_name]]
              # data = [['tom', 10], ['nick', 15], ['juli', 14]]
              #get
              df = pd.DataFrame(data, columns=['activity','activity_id','auth_protocol','auth_protocol_id','category_name','category_uid','class_name','class_uid','is_cleartext','dst_endpoint',
                                               'dst_user','enrichments','_time','logon_type','logon_type_id','displayMessage','ref_time','profile','session_uid','severity','severity_id',
                                               'src_endpoint','src_user','status','status_code','status_detail','status_id','type_uid','type_name'])
              '''
              #df.to_csv("data.csv")
              #df.to_csv("/tmp/data.csv", index=False,sep='\t', encoding='utf-8')
              '''output=[]
              output_record = {
                  'result': 'Ok',
                  'data': data

               }
              output.append(output_record)'''

              return json_data
              #return "data"
      Handler: app.lambda_handler
      Role: !GetAtt tsvtoparquetLambdaExecutionRole.Arn
      Runtime: python3.8
      Timeout: 120
      MemorySize: 128

  GlueCrawlerRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          -
           Effect: "Allow"
           Principal:
             Service:
              - "glue.amazonaws.com"
           Action:
              - "sts:AssumeRole"
      Path: "/"
      Policies:
        -
          PolicyName: "root"
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              -
               Effect: "Allow"
               Action: "*"
               Resource: "*"
 
  S3DataCrawler:
    DependsOn: GlueTable
    Type: AWS::Glue::Crawler
    Properties:
      Name: accessogCrawler
      Role: !GetAtt GlueCrawlerRole.Arn
      DatabaseName: !Ref GlueDatabase
      SchemaChangePolicy:
        UpdateBehavior: "UPDATE_IN_DATABASE"
        DeleteBehavior: "LOG"
      Targets:
          CatalogTargets:
           -
            DatabaseName: "firehosedb"
            Tables:
             - "access_logs_parquet"
Outputs:
   KinesisFirehose:
     Description: Kinesis Firehose Name
     Value: "accesslogs-sink-parquet"
   S3bucketname: 
     Value: !Ref MyS3Bucket
     Description: Name of the bucket created
   GlueDatabase: 
     Value: !Ref GlueDatabase
     Description: AWS Glue Database
   GlueTable: 
     Value: !Ref GlueTable
     Description: AWS Glue Table
   GlueCrawler: 
     Value: !Ref S3DataCrawler
     Description: AWS Glue Crawler
